# JavaScript 开发者应懂的 33 个概念


- 调用堆栈
- 原始类型
- 值类型和引用类型
- 隐式, 显式, 名义和鸭子类型
- == 与 ===, typeof 与 instanceof
- this, call, apply 和 bind
- 函数作用域, 块级作用域和词法作用域
- 闭包
- map, reduce, filter 等高阶函数
- 表达式和语句
- 变量提升
- Promise
- 立即执行函数, 模块化, 命名空间
- 递归
- 算法
- 数据结构
- 消息队列和事件循环
- setTimeout, setInterval 和 requestAnimationFrame
- 继承, 多态和代码复用
- 按位操作符, 类数组对象和类型化数组
- DOM 树和渲染过程
- new 与构造函数, instanceof 与实例
- 原型继承与原型链
- Object.create 和 Object.assign
- 工厂函数和类
- 设计模式
- Memoization
- 纯函数, 函数副作用和状态变化
- 耗性能操作和时间复杂度
- JavaScript 引擎
- 二进制, 十进制, 十六进制, 科学记数法
- 偏函数, 柯里化, Compose 和 Pipe
- 代码整洁之道

## 1.调用堆栈
- [MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack)
>调用栈是解析器(如浏览器中的的javascript解析器)的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数正在执行，什么函数被这个函数调用，下一个调用的函数是谁）  
- 当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。
- 任何被这个函数调用的函数会进一步添加到调用栈中，并且运行到它们被上个程序调用的位置。
- 当函数运行结束后，解释器将它从堆栈中取出，并在主代码列表中继续执行代码。
- 如果栈占用的空间比分配给它的空间还大，那么则会导致“堆栈溢出”错误。

### 1.1执行上下文的类型
JavaScript 中有三种执行上下文类型。

- 全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。  
  它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。  
  一个程序中只会有一个全局执行上下文。
- 函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。  
  每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。  
  函数上下文可以有任意多个。  
  每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。
- Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。

链接：https://juejin.im/post/5ba32171f265da0ab719a6d7



## 2.原始类型

基本类型（基本数值、基本数据类型）是指非 对象 并且无方法的数据。

在 JavaScript 中，共有6种基本数据类型：string，number，boolean，null，undefined，symbol

- [MDN-原始数据](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)


## 3.值类型和引用类型

- JavaScript中的变量类型有哪些？

  - （1）值类型：字符串（string）、数值（number）、布尔值（boolean）、none、undefined

  - （2）引用类型：对象（Object）、数组（Array）、函数（Function）

- [js中的值类型和引用类型的区别](https://www.cnblogs.com/leiting/p/8081413.html)
  - 值类型：1、占用空间固定，保存在栈中
    - 2、保存与复制的是值本身
    - 3、使用typeof检测数据的类型
    - 4、基本类型数据是值类型
  - 引用类型：1、占用空间不固定，保存在堆中
    - 2、保存与复制的是指向对象的一个指针
    - 3、使用instanceof检测数据类型
    - 4、使用new()方法构造出的对象是引用型


## 4.隐式, 显式, 名义和鸭子类型

```
var a = 42;
var b = a + ""; // 隐式强制类型转换
var c = String( a ); // 显式强制类型转换
```

- 隐式类型转换
  - 不同的数据类型之间可以做运算，是因为JavaScript引擎在运算之前会悄悄的把他们进行了隐式类型转换的
  - 比如，一个字符串可以和数字相加。
  - 如果字符串和数字相加，JavaScript会自动把数字转换成字符的，不管数字在前还是字符串在前
  - 1+null  // 1
  - 1+undefined // NaN
  - 1+NaN // NaN
- 显式解析数字字符串
  - 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。但解析和转换两者之间还是有明显的差别。
  - var a = "42";
  - var b = "42px";
  - Number( a ); // 42
  - parseInt( a ); // 42
  - Number( b ); // NaN
  - parseInt( b ); // 42
  - 解析允许字符串中含有非数字字符，解析按从做到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回NaN。

- []+{} //"[object Object]"
- {}+[] // 0

- ToString
  - 它负责处理非字符串到字符串的强制类型转换。
  - 基本类型值的字符串化规则为：null转换为“null”，undefined转换为“undefined”，true转换为“true”。
  - 数字的字符串化则遵循通用规则。不过那些极小和极大的数字使用指数形式：
  ```
  // 1.07 连续乘以七个 1000
  var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;
  // 七个1000一共21位数字
  a.toString(); // "1.07e21"
  ```
- JSON字符串化: JSON.stringify(..)并不是强制类型转换
```
JSON.stringify( 42 ); // "42"
JSON.stringify( "42" ); // ""42"" （含有双引号的字符串）
JSON.stringify( null ); // "null"
JSON.stringify( true ); // "true"

```
  - 所有安全的JSON值都可以使用JSON.stringify(..)字符串化。安全的JSON值是指你能够呈现为有效JSON格式的值。
  - JSON.stringify(..)在对象中遇到undefined、function和symbol时会自动将其忽略，在数组中则会返回null（以保证单元位置不变）。
  ```
  JSON.stringify(undefined); // undefined
  JSON.stringify(function () { }); // undefined
  JSON.stringify(
      [1, undefined, function () { }, 4]
  ); // "[1,null,null,4]"
  JSON.stringify(
      { a: 2, b: function () { } }
  ); // "{"a":2}"
  ```
  - 向JSON.stringify(..)传递一个可选参数replacer，它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除。
    - 如果replacer是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。
    - 如果replacer是一个函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回undefined，否则返回指定的值。
  ```
  var a = {
      b: 42,
      c: "42",
      d: [1, 2, 3]
  };
  JSON.stringify(a, ["b", "c"]); // "{"b":42,"c":"42"}"
  JSON.stringify(a, function (k, v) {
      if (k !== "c") return v;
  });
      // "{"b":42,"d":[1,2,3]}"
  ```

  - JSON.string还有一个可选参数space，用来指定输出的缩进格式。
    - space为正整数时是指定每一级缩进的字符数，它还可以是字符串，此时最前面的十个字符被用于每一级的缩进：
    ```
    var a = {
        b: 42,
        c: "42",
        d: [1, 2, 3]
    };
    JSON.stringify(a, null, 3);
    // "{
    // "b": 42,
    // "c": "42",
    // "d": [
    // 1,
    // 2,
    // 3
    // ]
    // }"
    JSON.stringify( a, null, "-----" );
    // "{
    // -----"b": 42,
    // -----"c": "42",
    // -----"d": [
    // ----------1,
    // ----------2,
    // ----------3
    // -----]
    // }"
    ```

#### 奇特的 `~` 运算符

- indexOf(..)不仅能够得到子字符串的位置，还可以用来检查字符串中是否包含指定的子字符串，相当于一个条件判断。例如：
```
var a = "Hello World";
if (a.indexOf("lo") >= 0) { // true
    // 找到匹配！
}
if (a.indexOf("lo") != -1) { // true
    // 找到匹配！
}
if (a.indexOf("ol") < 0) { // true
    // 没有找到匹配！
}
if (a.indexOf("ol") == -1) { // true
    // 没有找到匹配！
}
```
- = 0 和== -1这样的写法不是很好，**称为“抽象渗漏”**，意思是在代码中暴露了底层的实现细节，这里是指用-1作为失败时的返回值，这些细节应该被屏蔽掉。
  - 现在我们终于明白有什么用处了！和indexOf()一起可以将结果强制类型转换（实际上仅仅是转换）为真/假值：

```
var a = "Hello World";
~a.indexOf("lo"); // -4 <-- 真值!
if (~a.indexOf("lo")) { // true
    // 找到匹配！
}
~a.indexOf("ol"); // 0 <-- 假值!
!~a.indexOf("ol"); // true
if (!~a.indexOf("ol")) { // true
    // 没有找到匹配！
}
```

如果indexOf(..)返回-1，`~`将其转换为假值0，其他情况一律转换为真值。



- [你不知道的JavaScript（中卷）|强制类型转换](https://www.jianshu.com/p/777a89b4ed9a)

## 参考
- [33-js-concepts](https://github.com/leonardomso/33-js-concepts)
- [JavaScript 开发者应懂的 33 个概念](https://juejin.im/entry/5bc9aae56fb9a05d20687bf3)
