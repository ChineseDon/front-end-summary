# JavaScript 开发者应懂的 33 个概念


- [1.调用堆栈](#1调用堆栈)
- [2.原始类型](#2原始类型)
- [3.值类型和引用类型](#3值类型和引用类型)
- [4.隐式, 显式, 名义和鸭子类型](#4隐式-显式-名义和鸭子类型)
- [5.== 与 ===, typeof 与 instanceof](#5-vs--typeof-vs-instanceof)
- [6.this, call, apply 和 bind](#6-this-call-apply-和-bind)
- [7.函数作用域, 块级作用域和词法作用域](#7-函数作用域-块级作用域和词法作用域)
- [8.闭包](#8闭包)
- [9.map, reduce, filter 等高阶函数](#9-map-reduce-filter-等高阶函数)
- [10.表达式和语句](#10表达式和语句)
- [11.变量提升](#11变量提升)
- [12.Promise](#12Promise)
- [13.立即执行函数, 模块化, 命名空间](#13-立即执行函数-模块化-命名空间)
- [14.递归](#)
- [15.算法](#)
- [16.数据结构](#)
- [17.消息队列和事件循环](#)
- [18.setTimeout, setInterval 和 requestAnimationFrame](#)
- [19.继承, 多态和代码复用](#)
- [20.按位操作符, 类数组对象和类型化数组](#)
- [21.DOM 树和渲染过程](#)
- [22.new 与构造函数, instanceof 与实例](#)
- [23.原型继承与原型链](#)
- [24.Object.create 和 Object.assign](#)
- [25.工厂函数和类](#)
- [26.设计模式](#)
- [27.Memoization](#)
- [28.纯函数, 函数副作用和状态变化](#)
- [29.耗性能操作和时间复杂度](#)
- [30.JavaScript 引擎](#)
- [32.二进制, 十进制, 十六进制, 科学记数法](#)
- [33.偏函数, 柯里化, Compose 和 Pipe](#)
- [34.代码整洁之道](#)

## 1.调用堆栈
- [MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack)
>调用栈是解析器(如浏览器中的的javascript解析器)的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数正在执行，什么函数被这个函数调用，下一个调用的函数是谁）  
- 当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。
- 任何被这个函数调用的函数会进一步添加到调用栈中，并且运行到它们被上个程序调用的位置。
- 当函数运行结束后，解释器将它从堆栈中取出，并在主代码列表中继续执行代码。
- 如果栈占用的空间比分配给它的空间还大，那么则会导致“堆栈溢出”错误。

### 1.1执行上下文的类型
JavaScript 中有三种执行上下文类型。

- 全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。  
  它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。  
  一个程序中只会有一个全局执行上下文。
- 函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。  
  每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。  
  函数上下文可以有任意多个。  
  每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。
- Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。

链接：https://juejin.im/post/5ba32171f265da0ab719a6d7



## 2.原始类型

基本类型（基本数值、基本数据类型）是指非 对象 并且无方法的数据。

在 JavaScript 中，共有6种基本数据类型：string，number，boolean，null，undefined，symbol

- [MDN-原始数据](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)


## 3.值类型和引用类型

- JavaScript中的变量类型有哪些？

  - （1）值类型：字符串（string）、数值（number）、布尔值（boolean）、none、undefined

  - （2）引用类型：对象（Object）、数组（Array）、函数（Function）

- [js中的值类型和引用类型的区别](https://www.cnblogs.com/leiting/p/8081413.html)
  - 值类型：1、占用空间固定，保存在栈中
    - 2、保存与复制的是值本身
    - 3、使用typeof检测数据的类型
    - 4、基本类型数据是值类型
  - 引用类型：1、占用空间不固定，保存在堆中
    - 2、保存与复制的是指向对象的一个指针
    - 3、使用instanceof检测数据类型
    - 4、使用new()方法构造出的对象是引用型


## 4.隐式, 显式, 名义和鸭子类型

```
var a = 42;
var b = a + ""; // 隐式强制类型转换
var c = String( a ); // 显式强制类型转换
```

- 隐式类型转换
  - 不同的数据类型之间可以做运算，是因为JavaScript引擎在运算之前会悄悄的把他们进行了隐式类型转换的
  - 比如，一个字符串可以和数字相加。
  - 如果字符串和数字相加，JavaScript会自动把数字转换成字符的，不管数字在前还是字符串在前
  - 1+null  // 1
  - 1+undefined // NaN
  - 1+NaN // NaN
- 显式解析数字字符串
  - 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。但解析和转换两者之间还是有明显的差别。
  - var a = "42";
  - var b = "42px";
  - Number( a ); // 42
  - parseInt( a ); // 42
  - Number( b ); // NaN
  - parseInt( b ); // 42
  - 解析允许字符串中含有非数字字符，解析按从做到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回NaN。

- []+{} //"[object Object]"
- {}+[] // 0
  - 这是两个复杂数据结构相加的例子，**js的隐式类型转换**
  - 原因是有的js解释器会将开头的 {} 看作一个代码块，而不是一个js对象，于是真正参与运算的是+[]，就是将[]转换为number，于是得出答案0
  - 那么我们如何证明{}被看作一个代码块而不是一个js对象呢？很简单， 我们可以在{}里写上一些语句，比如:
  ```{console.log("hello")} + [] ```
- Number(undefined) // NaN
- Number(null)  // 0
- Number(NaN) // NaN
- Number(true)  // 1
- Number(false)  // 0

- ToString
  - 它负责处理非字符串到字符串的强制类型转换。
  - 基本类型值的字符串化规则为：null转换为“null”，undefined转换为“undefined”，true转换为“true”。
  - 数字的字符串化则遵循通用规则。不过那些极小和极大的数字使用指数形式：
  ```
  // 1.07 连续乘以七个 1000
  var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;
  // 七个1000一共21位数字
  a.toString(); // "1.07e21"
  ```
- JSON字符串化: JSON.stringify(..)并不是强制类型转换
```
JSON.stringify( 42 ); // "42"
JSON.stringify( "42" ); // ""42"" （含有双引号的字符串）
JSON.stringify( null ); // "null"
JSON.stringify( true ); // "true"

```
  - 所有安全的JSON值都可以使用JSON.stringify(..)字符串化。安全的JSON值是指你能够呈现为有效JSON格式的值。
  - JSON.stringify(..)在对象中遇到undefined、function和symbol时会自动将其忽略，在数组中则会返回null（以保证单元位置不变）。
  ```
  JSON.stringify(undefined); // undefined
  JSON.stringify(function () { }); // undefined
  JSON.stringify(
      [1, undefined, function () { }, 4]
  ); // "[1,null,null,4]"
  JSON.stringify(
      { a: 2, b: function () { } }
  ); // "{"a":2}"
  ```
  - 向JSON.stringify(..)传递一个可选参数replacer，它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除。
    - 如果replacer是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。
    - 如果replacer是一个函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回undefined，否则返回指定的值。
  ```
  var a = {
      b: 42,
      c: "42",
      d: [1, 2, 3]
  };
  JSON.stringify(a, ["b", "c"]); // "{"b":42,"c":"42"}"
  JSON.stringify(a, function (k, v) {
      if (k !== "c") return v;
  });
      // "{"b":42,"d":[1,2,3]}"
  ```

  - JSON.string还有一个可选参数space，用来指定输出的缩进格式。
    - space为正整数时是指定每一级缩进的字符数，它还可以是字符串，此时最前面的十个字符被用于每一级的缩进：
    ```
    var a = {
        b: 42,
        c: "42",
        d: [1, 2, 3]
    };
    JSON.stringify(a, null, 3);
    // "{
    // "b": 42,
    // "c": "42",
    // "d": [
    // 1,
    // 2,
    // 3
    // ]
    // }"
    JSON.stringify( a, null, "-----" );
    // "{
    // -----"b": 42,
    // -----"c": "42",
    // -----"d": [
    // ----------1,
    // ----------2,
    // ----------3
    // -----]
    // }"
    ```

- **奇特的 `~` 运算符**

- indexOf(..)不仅能够得到子字符串的位置，还可以用来检查字符串中是否包含指定的子字符串，相当于一个条件判断。例如：
```
var a = "Hello World";
if (a.indexOf("lo") >= 0) { // true
    // 找到匹配！
}
if (a.indexOf("lo") != -1) { // true
    // 找到匹配！
}
if (a.indexOf("ol") < 0) { // true
    // 没有找到匹配！
}
if (a.indexOf("ol") == -1) { // true
    // 没有找到匹配！
}
```
- = 0 和== -1这样的写法不是很好，**称为“抽象渗漏”**，意思是在代码中暴露了底层的实现细节，这里是指用-1作为失败时的返回值，这些细节应该被屏蔽掉。
  - 现在我们终于明白有什么用处了！和indexOf()一起可以将结果强制类型转换（实际上仅仅是转换）为真/假值：

```
var a = "Hello World";
~a.indexOf("lo"); // -4 <-- 真值!
if (~a.indexOf("lo")) { // true
    // 找到匹配！
}
~a.indexOf("ol"); // 0 <-- 假值!
!~a.indexOf("ol"); // true
if (!~a.indexOf("ol")) { // true
    // 没有找到匹配！
}
```

如果indexOf(..)返回-1，`~`将其转换为假值0，其他情况一律转换为真值。


- 假值的相等比较
```
"0" == null; // false
"0" == undefined; // false
"0" == false; // true -- 晕！
"0" == NaN; // false
"0" == 0; // true
"0" == ""; // false
false == null; // false
false == undefined; // false
false == NaN; // false
false == 0; // true -- 晕！
false == ""; // true -- 晕！
false == []; // true -- 晕！
false == {}; // false
"" == null; // false
"" == undefined; // false
"" == NaN; // false
"" == 0; // true -- 晕！
"" == []; // true -- 晕！
"" == {}; // false
0 == null; // false
0 == undefined; // false
0 == NaN; // false
0 == []; // true -- 晕！
0 == {}; // false
3、极端情况

[] == ![] // true
```
- [你不知道的JavaScript（中卷）|强制类型转换](https://www.jianshu.com/p/777a89b4ed9a)
_____________________________
______________________________

- 编程语言按照数据类型大体可以分为两类，一类是静态类型语言，另一类是动态类型语言
  - 静态类型语言在编译时便已确定变量的类型，
  - 动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。

- 鸭子类型指导我们只关注对象的行为，而不关注对象本身，


## 5.== vs ===, typeof vs instanceof
- `===` 严格相等，会比较两个值的类型和值
- `==`  抽象相等，比较时，会先进行类型转换，然后再比较值
- `==` 涉及到隐式类型转换，`<`（小于号） 也涉及到隐式类型转换。
- typeof：

js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉

000：对象  
010：浮点数  
100：字符串  
110：布尔  
1：整数  

but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。  
null：所有机器码均为0  
undefined：用 −2^30 整数来表示  
所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待。  

```
// Numbers
typeof 37 === 'number';
typeof 3.14 === 'number';
typeof Math.LN2 === 'number';
typeof Infinity === 'number';
typeof NaN === 'number'; // 尽管NaN是"Not-A-Number"的缩写,意思是"不是一个数字"
typeof Number(1) === 'number'; // 不要这样使用!

// Strings
typeof "" === 'string';
typeof "bla" === 'string';
typeof (typeof 1) === 'string'; // typeof返回的肯定是一个字符串
typeof String("abc") === 'string'; // 不要这样使用!

// Booleans
typeof true === 'boolean';
typeof false === 'boolean';
typeof Boolean(true) === 'boolean'; // 不要这样使用!

// Symbols
typeof Symbol() === 'symbol';
typeof Symbol('foo') === 'symbol';
typeof Symbol.iterator === 'symbol';

// Undefined
typeof undefined === 'undefined';
typeof blabla === 'undefined'; // 一个未定义的变量,或者一个定义了却未赋初值的变量

// Objects
typeof {a:1} === 'object';

// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型
typeof [1, 2, 4] === 'object';

typeof new Date() === 'object';

// 下面的容易令人迷惑，不要这样使用！
typeof new Boolean(true) === 'object';
typeof new Number(1) ==== 'object';
typeof new String("abc") === 'object';

// 函数
typeof function(){} === 'function';
typeof Math.sin === 'function';


typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象的typeof返回值都是object，这就会造成一些误差。
```

-  instance_of

```
function new_instance_of(leftVaule, rightVaule) { 
    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
    while (true) {
    	if (leftVaule === null) {
            return false;	
        }
        if (leftVaule === rightProto) {
            return true;	
        } 
        leftVaule = leftVaule.__proto__ 
    }
}
```
- 其实 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。
- 因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，
- 如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。


## 6. this, call, apply 和 bind

- call与apply:

```
var obj = {
  name: 'linxin'
}

function func(age, sex) {
  console.log(this.name,age,sex);
}

func.call(obj,12,'女');         // linxin 12 女
func.apply(obj, [18, '女']);        //linxin 18 女
```

- 模拟实现

```
Function.prototype.newCall = function(context) {
  context.fn = this;  // 通过this获取call的函数
  context.fn();
  delete context.fn;
}
let foo = {
  value: 1
}
function bar() {
  console.log(this.value);
}
bar.newCall (foo); // 1

但是如果说有传参数呢？
所以我们可以进行优化一下，因为传入的参数数量是不确定的，所以我们可以从Arguments对象中去获取，这个比较简单。
问题是参数是不确定的，我们如何传入到我们要执行的函数中去呢 ？ 这里我们有两种选择：一种是通过eval拼接的方式，另一种就要用到es6了。

Function.prototype.newCall = function(context, ...parameter) {
  if (typeof context === 'object') {
    context = context || window
  } else {
    context = Object.create(null)
  }
  let fn = Symbol()
  context[fn] = this
  context[fn](...parameter);
  delete context[fn]
}
let person = {
  name: 'Abiel'
}
function sayHi(age,sex) {
  console.log(this.name, age, sex);
}
sayHi.newCall (person, 25, '男'); // Abiel 25 

实现了call之后，apply也是同样的思路。
===========================================
apply实现：

Function.prototype.newApply = function(context, parameter) {
  if (typeof context === 'object') {
    context = context || window
  } else {
    context = Object.create(null)
  }
  let fn = Symbol()
  context[fn] = this
  context[fn](...parameter);
  delete context[fn]
}
```

- bind
```
初体验：

Function.prototype.bind = function (context) {
  var me = this
  return function () { // bind之后得到的函数
    return me.call(context)  // 执行是改变this执行
  }
}


加入参数：

Function.prototype.bind = function (context,...innerArgs) {
  var me = this
  return function (...finnalyArgs) {
    return me.call(context,...innerArgs,...finnalyArgs)
  }
}
let person = {
  name: 'Abiel'
}
function sayHi(age,sex) {
  console.log(this.name, age, sex);
}
let personSayHi = sayHi.bind(person, 25)
personSayHi('男')
```



- [call、apply和bind的实现 ](https://github.com/Abiel1024/blog/issues/16)



## 7. 函数作用域, 块级作用域和词法作用域
>作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）的规则

>作用域有两种主要工作模型：词法作用域和动态作用域。

- JavaScript采用词法作用域(lexical scoping)，也就是静态作用域。
- 词法作用域注重的是所谓的Write-Time，即编程时的上下文，而动态作用域以及常见的this的用法，都是Run-Time，即运行时上下文。词法作用域关注的是函数在何处被定义，而动态作用域关注的是函数在何处被调用。JavaScript是典型的词法作用域的语言，即一个符号参照到语境中符号名字出现的地方，局部变量缺省有着词法作用域。
- bash就是动态作用域

- JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文

```
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();复制代码var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();复制代码两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？
答案就是执行上下文栈的变化不一样。

链接：https://juejin.im/post/58eaecdea0bb9f0069271861

```
- [冴羽的博客](https://github.com/mqyqingfeng/Blog)

## 8.闭包
- mdn: 闭包是函数和声明该函数的词法环境的组合。
- 
```
var name = "The Window";
　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　return function(){
　　　　　　　　return this.name;
　　　　　　};
　　　　}
　　};
　　alert(object.getNameFunc()());
运行结果：The Window

解释：object.getNameFunc()这是属于方法调用，this指针指向的是object，可以用一个变量tmp引用它的结果，实际上tmp就是这个方法返回的那个匿名函数function(){return this.name;};，此时并没有执行内部代码，执行tmp()时，也就是object.getNameFunc()()时，属于函数调用（另一篇博文详解了这里，链接），this指针指向window，最终返回The Window。

题目二
var name = "The Window";
　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　var that = this;
　　　　　　return function(){
　　　　　　　　return that.name;
　　　　　　};
　　　　}
　　};
　　alert(object.getNameFunc()());
运行结果：My Object

解释：在调用getNameFunc()时，属于方法调用，那么this指针指向object，把它被that引用，那么返回的匿名函数中时刻保持对object的引用

链接：https://www.jianshu.com/p/796e903754f1

```

## 9. map, reduce, filter 等高阶函数

>高阶函数(higher-order function)指操作函数的函数，一般地，有以下两种情况  
1、函数可以作为参数被传递  
2、函数可以作为返回值输出

```
forEach: 
// 对于古董浏览器，如IE6-IE8

if (typeof Array.prototype.forEach != "function") {
  Array.prototype.forEach = function (fn, context) {
    for (var k = 0, length = this.length; k < length; k++) {
      if (typeof fn === "function" && Object.prototype.hasOwnProperty.call(this, k)) {
        fn.call(context, this[k], k, this);
      }
    }
  };
}

=============================================
map: 

让IE6-IE8浏览器也支持map方法：

if (typeof Array.prototype.map != "function") {
  Array.prototype.map = function (fn, context) {
    var arr = [];
    if (typeof fn === "function") {
      for (var k = 0, length = this.length; k < length; k++) {      
         arr.push(fn.call(context, this[k], k, this));
      }
    }
    return arr;
  };
}

=================================================

filter:

if (typeof Array.prototype.filter != "function") {
  Array.prototype.filter = function (fn, context) {
    var arr = [];
    if (typeof fn === "function") {
       for (var k = 0, length = this.length; k < length; k++) {
          fn.call(context, this[k], k, this) && arr.push(this[k]);
       }
    }
    return arr;
  };
}

==============================================
some:

IE6-IE8扩展如下：

if (typeof Array.prototype.some != "function") {
  Array.prototype.some = function (fn, context) {
	var passed = false;
	if (typeof fn === "function") {
   	  for (var k = 0, length = this.length; k < length; k++) {
		  if (passed === true) break;
		  passed = !!fn.call(context, this[k], k, this);
	  }
    }
	return passed;
  };
}

=========================================
every: 
E6-IE8扩展（与some相比就是true和false调换一下）：

if (typeof Array.prototype.every != "function") {
  Array.prototype.every = function (fn, context) {
    var passed = true;
    if (typeof fn === "function") {
       for (var k = 0, length = this.length; k < length; k++) {
          if (passed === false) break;
          passed = !!fn.call(context, this[k], k, this);
      }
    }
    return passed;
  };
}

==========================================

indexOf:

if (typeof Array.prototype.indexOf != "function") {
  Array.prototype.indexOf = function (searchElement, fromIndex) {
    var index = -1;
    fromIndex = fromIndex * 1 || 0;

    for (var k = 0, length = this.length; k < length; k++) {
      if (k >= fromIndex && this[k] === searchElement) {
          index = k;
          break;
      }
    }
    return index;
  };
}
```


- [ ES5 中新增的 Array 方法详细说明 —— 张鑫旭](https://www.zhangxinxu.com/wordpress/2013/04/es5新增数组方法/)

## 10. 表达式和语句

- 表达式在js中是短语，语句就是js的整句活命令；表达式计算出一个值，但语句用来执行以使某件事发生。《JavaScript权威指南》（第6版）

## 11. 变量提升

- 变量提升即: 将变量声明提升到它所在作用域的最开始的部分
```
function fn () {
　　console.log(a); // undefined
　　var a = 'aaa';
　　console.log(a); // aaa
}

实际上上面的代码是按照以下来执行的

function fn () {
　　var a; // 变量提升，函数作用域范围内
　　console.log(a);
　　a = 'aaa';
　　console.log(a);
}
```

- 函数提升

  - js中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升！如:

```
console.log(f1); // function f1() {}   
console.log(f2); // undefined  
function f1() {}
var f2 = function() {}
```

  - 只所以会有以上的打印结果，是由于js中的函数提升导致代码实际上是按照以下来执行的：

```
function f1() {} // 函数提升，整个代码块提升到文件的最开始<br>　　　　　console.log(f1);   
console.log(f2);   
var f2 = function() {}
```
- [深入理解js的变量提升和函数提升](https://www.cnblogs.com/kawask/p/6225317.html)

## 12. Promise

- [Promise简单实现（正常思路版）](https://www.jianshu.com/p/473cd754311f)


## 13. 立即执行函数, 模块化, 命名空间



## 参考
- [33-js-concepts](https://github.com/leonardomso/33-js-concepts)
- [JavaScript 开发者应懂的 33 个概念](https://juejin.im/entry/5bc9aae56fb9a05d20687bf3)
