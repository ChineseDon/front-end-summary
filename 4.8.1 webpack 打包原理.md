# webpack 打包原理



>webpack 中每个模块有一个唯一的 id，是从 0 开始递增的。  
整个打包后的 bundle.js 是一个匿名函数自执行。  
参数则为一个数组。数组的每一项都为个 function。  
function 的内容则为每个模块的内容，并按照 require 的顺序排列。

>识别入口文件,识别模块依赖，来打包代码。webpack做的就是分析代码,转换代码，编译代码，输出代码

## Webpack的两个最核心的原理分别是：

- 一切皆模块
>正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。   
因此，你可以require('myJSfile.js')亦可以require('myCSSfile.css')。   
这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。

- 按需加载
>传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。  
但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。  
因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。


## 如何实现一个简单的webpack
- 读取文件分析模块依赖
- 对模块进行解析执行(深度遍历)
- 针对不同的模块使用相应的loader
- 编译模块，生成抽象语法树AST。
- 循环遍历AST树，拼接输出js。


## loader原理
>在解析对于文件，会自动去调用响应的loader,  
loader 本质上是一个函数，输入参数是一个字符串，输出参数也是一个字符串。  
当然，输出的参数会被当成是 JS 代码，从而被 esprima 解析成 AST，触发进一步的依赖解析。  
webpack会按照从右到左的顺序执行loader。


>一种正确的思路是：  
使用JS代码解析工具（如[esprima](https://github.com/jquery/esprima)或者[acorn](https://github.com/ternjs/acorn)），  
将JS代码转换成抽象语法树（AST），  
再对AST进行遍历。  
这部分的核心代码是 [parse.js](https://github.com/youngwind/fake-webpack/blob/1bfcd0edf1/lib/parse.js)。

## webpack优化
- 1.externals配置优化  
设置externals配置项分离不需要打包的库文件，然后在模版文件中使用script引入即可，配置代码片段如下：
```
externals: {
  'jquery': 'jquery'
},
```
- 2.

- 参考: [webpack优化入门详解](https://juejin.im/post/5a869044f265da4e9c632f94)
  - [vue + webpack 前端性能优化](https://juejin.im/post/5bc5c106e51d450e7a253e1b)

##  参考
- [webpack 打包原理](https://www.jianshu.com/p/e24ed38d89fd)
- [如何实现一个简单的webpack](https://github.com/youngwind/blog/issues/99)
- [webpack 源码解析](https://lihuanghe.github.io/2016/05/30/webpack-source-analyse.html)
- [Webpack——令人困惑的地方](https://github.com/chemdemo/chemdemo.github.io/issues/13)

