#  现在有一个函数A和函数B，请你实现B继承A

## 1.使用原型链

>思想：**利用原型让一个引用类型继承另一个引用类型的属性和方法**  
b继承a实际上就是创建a的实例，并将该实例赋予给b.prototype.实现的本质是重写原型对象，代之以一个新类型的实例。  
换句话说原来存在于a中的属性和方法现在也存在于b.prototype中  

```
function A() {}
function B() {}

B.prototype = new A();

```

-  缺点：
  - 1.包含引用类型值的原型属性会被所有实例共享，  
    (基本类型值也会被所有实例共享，但是子类型实例可以通过设置一个同名属性屏蔽超类型原型中的属性从而拥有自己的属性，  
    而引用类型的值是会修改原型中的属性的，从而影响所有实例)  
    这也是为什么要在构造函数中，而不是在原型对象中定义属性的原因。

  - 2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。  
  实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。

>基于以上两点，实践中很少会单独使用原型链。
--------------------- 


## 2.借用构造函数

>思想：**在子类型构造函数的内部调用超类型构造函数。**  
 函数只不过是在特定环境中执行代码的对象。调用 call() 方法，

```
function A(){}
function B(){
  A.call(this);
}
```

- 优点：
  - 1.可以在子类型中向超类型传递参数（相对于原型链而言）。

  - 2.可以解决原型链继承所带来的引用类型值所带来的问题。

- 缺点：
  - 1.为了确保SuperType构造函数不会重写子类型的属性，必须在调用超类型构造函数后，再添加应该在子类型中定义的属性。  
  （这也算不上什么缺点，原型链也是这样的，必须确保超类型的实例替换掉子类型的原型之后再定义自己的原型方法）

  - 2.方法都在构造函数中定义了，因此函数复用就无从谈起了。

  - 3.在超类型的原型中定义的方法，对子类型而言也是不可见的，  
    （？因为这是原型链的原理决定的，只有子类型实例会继承超类型的属性和原型方法，而构造函数模式只是在子类型中引用了超类型构造函数）  
    结果所有类型都只能使用构造函数模式。

>故借用构造函数模式也是很少单独使用的。

## 3.组合继承

>思想：用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。  
这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。


```
function B(){}
function A(){}
B.prototype = new A();

function B(){
  A.call(this);
}
```



- 优点：
  - 1.可以让每个不同的实例拥有自己的属性，同时又共享了相同的方法。

  - 2.避免了原型链继承和借用构造函数继承的缺点，融合了它们的优点。

- 缺点：
  - 1.无论什么情况下，都会调用两次超类型构造函数。

故组合继承模式成为了JS中最常用的继承模式。

而且，instanceof和isPrototypeOf ()也能用于识别基于组合继承创建的对象。


### 4.原型式继承


## 参考
- [在JS中b如何继承a](https://blog.csdn.net/lee1996jun/article/details/79531960)
